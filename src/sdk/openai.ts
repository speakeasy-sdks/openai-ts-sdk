/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import * as utils from "../internal/utils";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { AxiosInstance, AxiosRequestConfig, AxiosResponse } from "axios";

/**
 * The OpenAI REST API
 */
export class OpenAI {
  _defaultClient: AxiosInstance;
  _securityClient: AxiosInstance;
  _serverURL: string;
  _language: string;
  _sdkVersion: string;
  _genVersion: string;

  constructor(
    defaultClient: AxiosInstance,
    securityClient: AxiosInstance,
    serverURL: string,
    language: string,
    sdkVersion: string,
    genVersion: string
  ) {
    this._defaultClient = defaultClient;
    this._securityClient = securityClient;
    this._serverURL = serverURL;
    this._language = language;
    this._sdkVersion = sdkVersion;
    this._genVersion = genVersion;
  }

  /**
   * Immediately cancel a fine-tune job.
   *
   */
  async cancelFineTune(
    req: operations.CancelFineTuneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CancelFineTuneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CancelFineTuneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/fine-tunes/{fine_tune_id}/cancel",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CancelFineTuneResponse =
      new operations.CancelFineTuneResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.fineTune = utils.objectToClass(httpRes?.data, shared.FineTune);
        }
        break;
    }

    return res;
  }

  /**
   * Answers the specified question using the provided documents and examples.
   *
   * The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
   *
   *
   * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
   */
  async createAnswer(
    req: shared.CreateAnswerRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateAnswerResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateAnswerRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/answers";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateAnswerResponse =
      new operations.CreateAnswerResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createAnswerResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateAnswerResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Creates a completion for the chat message
   */
  async createChatCompletion(
    req: shared.CreateChatCompletionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateChatCompletionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateChatCompletionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/chat/completions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateChatCompletionResponse =
      new operations.CreateChatCompletionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createChatCompletionResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateChatCompletionResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Classifies the specified `query` using provided examples.
   *
   * The endpoint first [searches](/docs/api-reference/searches) over the labeled examples
   * to select the ones most relevant for the particular query. Then, the relevant examples
   * are combined with the query to construct a prompt to produce the final label via the
   * [completions](/docs/api-reference/completions) endpoint.
   *
   * Labeled examples can be provided via an uploaded `file`, or explicitly listed in the
   * request using the `examples` parameter for quick tests and small scale use cases.
   *
   *
   * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
   */
  async createClassification(
    req: shared.CreateClassificationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateClassificationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateClassificationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/classifications";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateClassificationResponse =
      new operations.CreateClassificationResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createClassificationResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateClassificationResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Creates a completion for the provided prompt and parameters
   */
  async createCompletion(
    req: shared.CreateCompletionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateCompletionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateCompletionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/completions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateCompletionResponse =
      new operations.CreateCompletionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createCompletionResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateCompletionResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Creates a new edit for the provided input, instruction, and parameters.
   */
  async createEdit(
    req: shared.CreateEditRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEditResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateEditRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/edits";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateEditResponse =
      new operations.CreateEditResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createEditResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateEditResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Creates an embedding vector representing the input text.
   */
  async createEmbedding(
    req: shared.CreateEmbeddingRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateEmbeddingResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateEmbeddingRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/embeddings";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateEmbeddingResponse =
      new operations.CreateEmbeddingResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createEmbeddingResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateEmbeddingResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
   *
   */
  async createFile(
    req: shared.CreateFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateFileResponse =
      new operations.CreateFileResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.openAIFile = utils.objectToClass(
            httpRes?.data,
            shared.OpenAIFile
          );
        }
        break;
    }

    return res;
  }

  /**
   * Creates a job that fine-tunes a specified model from a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.
   *
   * [Learn more about Fine-tuning](/docs/guides/fine-tuning)
   *
   */
  async createFineTune(
    req: shared.CreateFineTuneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateFineTuneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateFineTuneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/fine-tunes";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateFineTuneResponse =
      new operations.CreateFineTuneResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.fineTune = utils.objectToClass(httpRes?.data, shared.FineTune);
        }
        break;
    }

    return res;
  }

  /**
   * Creates an image given a prompt.
   */
  async createImage(
    req: shared.CreateImageRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateImageResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateImageRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/images/generations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateImageResponse =
      new operations.CreateImageResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.imagesResponse = utils.objectToClass(
            httpRes?.data,
            shared.ImagesResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Creates an edited or extended image given an original image and a prompt.
   */
  async createImageEdit(
    req: shared.CreateImageEditRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateImageEditResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateImageEditRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/images/edits";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateImageEditResponse =
      new operations.CreateImageEditResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.imagesResponse = utils.objectToClass(
            httpRes?.data,
            shared.ImagesResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Creates a variation of a given image.
   */
  async createImageVariation(
    req: shared.CreateImageVariationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateImageVariationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateImageVariationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/images/variations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateImageVariationResponse =
      new operations.CreateImageVariationResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.imagesResponse = utils.objectToClass(
            httpRes?.data,
            shared.ImagesResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Classifies if text violates OpenAI's Content Policy
   */
  async createModeration(
    req: shared.CreateModerationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateModerationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateModerationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/moderations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateModerationResponse =
      new operations.CreateModerationResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createModerationResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateModerationResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.
   *
   * To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.
   *
   * The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
   *
   *
   * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
   */
  async createSearch(
    req: operations.CreateSearchRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateSearchResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.CreateSearchRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/engines/{engine_id}/search",
      req
    );

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "createSearchRequest",
        "json"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateSearchResponse =
      new operations.CreateSearchResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createSearchResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateSearchResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Transcribes audio into the input language.
   */
  async createTranscription(
    req: shared.CreateTranscriptionRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTranscriptionResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateTranscriptionRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/audio/transcriptions";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateTranscriptionResponse =
      new operations.CreateTranscriptionResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createTranscriptionResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateTranscriptionResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Translates audio into into English.
   */
  async createTranslation(
    req: shared.CreateTranslationRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.CreateTranslationResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new shared.CreateTranslationRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/audio/translations";

    let [reqBodyHeaders, reqBody]: [object, any] = [{}, {}];

    try {
      [reqBodyHeaders, reqBody] = utils.serializeRequestBody(
        req,
        "request",
        "multipart"
      );
    } catch (e: unknown) {
      if (e instanceof Error) {
        throw new Error(`Error serializing request body, cause: ${e.message}`);
      }
    }

    const client: AxiosInstance = this._defaultClient;

    const headers = { ...reqBodyHeaders, ...config?.headers };
    if (reqBody == null || Object.keys(reqBody).length === 0)
      throw new Error("request body is required");

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "post",
      headers: headers,
      data: reqBody,
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.CreateTranslationResponse =
      new operations.CreateTranslationResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.createTranslationResponse = utils.objectToClass(
            httpRes?.data,
            shared.CreateTranslationResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Delete a file.
   */
  async deleteFile(
    req: operations.DeleteFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/files/{file_id}", req);

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "delete",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.DeleteFileResponse =
      new operations.DeleteFileResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.deleteFileResponse = utils.objectToClass(
            httpRes?.data,
            shared.DeleteFileResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization.
   */
  async deleteModel(
    req: operations.DeleteModelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DeleteModelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DeleteModelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/models/{model}", req);

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "delete",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.DeleteModelResponse =
      new operations.DeleteModelResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.deleteModelResponse = utils.objectToClass(
            httpRes?.data,
            shared.DeleteModelResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Returns the contents of the specified file
   */
  async downloadFile(
    req: operations.DownloadFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.DownloadFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.DownloadFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/files/{file_id}/content",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.DownloadFileResponse =
      new operations.DownloadFileResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.downloadFile200ApplicationJSONString = JSON.stringify(
            httpRes?.data
          );
        }
        break;
    }

    return res;
  }

  /**
   * Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
   *
   * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
   */
  async listEngines(
    config?: AxiosRequestConfig
  ): Promise<operations.ListEnginesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/engines";

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListEnginesResponse =
      new operations.ListEnginesResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.listEnginesResponse = utils.objectToClass(
            httpRes?.data,
            shared.ListEnginesResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Returns a list of files that belong to the user's organization.
   */
  async listFiles(
    config?: AxiosRequestConfig
  ): Promise<operations.ListFilesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/files";

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListFilesResponse = new operations.ListFilesResponse({
      statusCode: httpRes.status,
      contentType: contentType,
      rawResponse: httpRes,
    });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.listFilesResponse = utils.objectToClass(
            httpRes?.data,
            shared.ListFilesResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Get fine-grained status updates for a fine-tune job.
   *
   */
  async listFineTuneEvents(
    req: operations.ListFineTuneEventsRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.ListFineTuneEventsResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.ListFineTuneEventsRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/fine-tunes/{fine_tune_id}/events",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const queryParams: string = utils.serializeQueryParams(req);

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url + queryParams,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListFineTuneEventsResponse =
      new operations.ListFineTuneEventsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.listFineTuneEventsResponse = utils.objectToClass(
            httpRes?.data,
            shared.ListFineTuneEventsResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * List your organization's fine-tuning jobs
   *
   */
  async listFineTunes(
    config?: AxiosRequestConfig
  ): Promise<operations.ListFineTunesResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/fine-tunes";

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListFineTunesResponse =
      new operations.ListFineTunesResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.listFineTunesResponse = utils.objectToClass(
            httpRes?.data,
            shared.ListFineTunesResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Lists the currently available models, and provides basic information about each one such as the owner and availability.
   */
  async listModels(
    config?: AxiosRequestConfig
  ): Promise<operations.ListModelsResponse> {
    const baseURL: string = this._serverURL;
    const url: string = baseURL.replace(/\/$/, "") + "/models";

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.ListModelsResponse =
      new operations.ListModelsResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.listModelsResponse = utils.objectToClass(
            httpRes?.data,
            shared.ListModelsResponse
          );
        }
        break;
    }

    return res;
  }

  /**
   * Retrieves a model instance, providing basic information about it such as the owner and availability.
   *
   * @deprecated this method will be removed in a future release, please migrate away from it as soon as possible
   */
  async retrieveEngine(
    req: operations.RetrieveEngineRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveEngineResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveEngineRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/engines/{engine_id}", req);

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.RetrieveEngineResponse =
      new operations.RetrieveEngineResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.engine = utils.objectToClass(httpRes?.data, shared.Engine);
        }
        break;
    }

    return res;
  }

  /**
   * Returns information about a specific file.
   */
  async retrieveFile(
    req: operations.RetrieveFileRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveFileResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveFileRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/files/{file_id}", req);

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.RetrieveFileResponse =
      new operations.RetrieveFileResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.openAIFile = utils.objectToClass(
            httpRes?.data,
            shared.OpenAIFile
          );
        }
        break;
    }

    return res;
  }

  /**
   * Gets info about the fine-tune job.
   *
   * [Learn more about Fine-tuning](/docs/guides/fine-tuning)
   *
   */
  async retrieveFineTune(
    req: operations.RetrieveFineTuneRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveFineTuneResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveFineTuneRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(
      baseURL,
      "/fine-tunes/{fine_tune_id}",
      req
    );

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.RetrieveFineTuneResponse =
      new operations.RetrieveFineTuneResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.fineTune = utils.objectToClass(httpRes?.data, shared.FineTune);
        }
        break;
    }

    return res;
  }

  /**
   * Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
   */
  async retrieveModel(
    req: operations.RetrieveModelRequest,
    config?: AxiosRequestConfig
  ): Promise<operations.RetrieveModelResponse> {
    if (!(req instanceof utils.SpeakeasyBase)) {
      req = new operations.RetrieveModelRequest(req);
    }

    const baseURL: string = this._serverURL;
    const url: string = utils.generateURL(baseURL, "/models/{model}", req);

    const client: AxiosInstance = this._defaultClient;

    const httpRes: AxiosResponse = await client.request({
      validateStatus: () => true,
      url: url,
      method: "get",
      ...config,
    });

    const contentType: string = httpRes?.headers?.["content-type"] ?? "";

    if (httpRes?.status == null) {
      throw new Error(`status code not found in response: ${httpRes}`);
    }

    const res: operations.RetrieveModelResponse =
      new operations.RetrieveModelResponse({
        statusCode: httpRes.status,
        contentType: contentType,
        rawResponse: httpRes,
      });
    switch (true) {
      case httpRes?.status == 200:
        if (utils.matchContentType(contentType, `application/json`)) {
          res.model = utils.objectToClass(httpRes?.data, shared.Model);
        }
        break;
    }

    return res;
  }
}
